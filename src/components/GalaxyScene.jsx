import React, { useRef, useEffect } from 'react';import * as THREE from 'three';export default function GalaxyScene({ isActive }) {  const mountRef = useRef(null);  const isActiveRef = useRef(isActive);    useEffect(() => {    isActiveRef.current = isActive;  }, [isActive]);  useEffect(() => {    if (!mountRef.current) return;    let mesh; // Declared here first    let animationId;    let time = 0;    let spiralSpeed = 0.08;        const scene = new THREE.Scene();    scene.background = new THREE.Color(0x000208);        const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 1000);    camera.position.set(0, 25, 35);    camera.lookAt(0, 0, 0);        const renderer = new THREE.WebGLRenderer({antialias: true});    renderer.setSize(window.innerWidth, window.innerHeight);    renderer.setPixelRatio(window.devicePixelRatio);    mountRef.current.appendChild(renderer.domElement);        // Generate galaxy data    const particleData = [];    const count = 50000;        for(let i = 0; i < count; i++) {      const arm = i % 3;      const armAngle = (arm / 3) * Math.PI * 2;            const r = Math.pow(Math.random(), 0.7) * 20;      const twist = r * 0.4;      const angle = armAngle + twist + (Math.random()-0.5)*0.8;            const thickness = r < 4 ? 2.5 : 0.8;      const y = (Math.random()-0.5) * thickness;            const x = r * Math.cos(angle);      const z = r * Math.sin(angle) * 0.7;            const scatterR = 80 + Math.random() * 50;      const scatterTheta = Math.random() * Math.PI * 2;      const scatterPhi = Math.acos(2*Math.random()-1);            particleData.push({        gx: x, gy: y, gz: z,        gr: r, gangle: angle,        sx: scatterR * Math.sin(scatterPhi) * Math.cos(scatterTheta),        sy: scatterR * Math.sin(scatterPhi) * Math.sin(scatterTheta),        sz: scatterR * Math.cos(scatterPhi),        type: r < 3 ? 'core' : r < 8 ? 'inner' : r < 14 ? 'mid' : 'outer',        phase: Math.random() * Math.PI * 2      });    }        // Create system    const geometry = new THREE.BufferGeometry();    const positions = new Float32Array(count * 3);    const colors = new Float32Array(count * 3);    const sizes = new Float32Array(count);        const canvas = document.createElement('canvas');    canvas.width = 256; canvas.height = 256;    const ctx = canvas.getContext('2d');    const grad = ctx.createRadialGradient(128,128,0,128,128,128);    grad.addColorStop(0, 'rgba(255,255,255,1)');    grad.addColorStop(0.2, 'rgba(255,220,255,0.6)');    grad.addColorStop(0.5, 'rgba(200,100,255,0.2)');    grad.addColorStop(1, 'rgba(0,0,0,0)');    ctx.fillStyle = grad;    ctx.fillRect(0,0,256,256);        const palette = {      core: new THREE.Color(0xffffff),      inner: new THREE.Color(0xff69b4),      mid: new THREE.Color(0x9370db),      outer: new THREE.Color(0x4169e1)    };        for(let i = 0; i < count; i++) {      const i3 = i * 3;      const p = particleData[i];            positions[i3] = p.sx;      positions[i3+1] = p.sy;      positions[i3+2] = p.sz;            const c = palette[p.type];      colors[i3] = c.r;      colors[i3+1] = c.g;      colors[i3+2] = c.b;            sizes[i] = p.type === 'core' ? 0.6 : p.type === 'inner' ? 0.35 : 0.18;    }        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));        const material = new THREE.PointsMaterial({      size: 0.35,      map: new THREE.CanvasTexture(canvas),      vertexColors: true,      transparent: true,      opacity: 0.9,      blending: THREE.AdditiveBlending,      depthWrite: false,      sizeAttenuation: true    });        mesh = new THREE.Points(geometry, material); // Assigned here    scene.add(mesh);        // Handle resize    const handleResize = () => {      camera.aspect = window.innerWidth/window.innerHeight;      camera.updateProjectionMatrix();      renderer.setSize(window.innerWidth, window.innerHeight);    };    window.addEventListener('resize', handleResize);        // Animation loop    function animate() {      animationId = requestAnimationFrame(animate);      time += 0.016;            const targetSpeed = isActiveRef.current ? 0.35 : 0.08;      spiralSpeed += (targetSpeed - spiralSpeed) * 0.05;            const expansionScale = isActiveRef.current ? 1.3 : 1.0;      const pulse = 1 + Math.sin(time * (isActiveRef.current ? 4 : 2)) * (isActiveRef.current ? 0.15 : 0.1);      const currentScale = expansionScale * pulse;            const pos = mesh.geometry.attributes.position.array;            const formation = Math.min(1, time / 25);      const rotation = time * spiralSpeed;            for(let i = 0; i < count; i++) {        const i3 = i * 3;        const p = particleData[i];                const orbitAngle = p.gangle + rotation * (20 / (p.gr + 2));        const r = p.gr * currentScale;                let tx = r * Math.cos(orbitAngle);        let ty = p.gy + Math.sin(time + p.phase) * 0.3;        let tz = r * Math.sin(orbitAngle) * 0.7;                let t = formation;        if(t < 0.3) {          t = t * t * 3;        } else if(t < 0.7) {          t = 0.27 + (t-0.3) * 1.5;        } else {          t = 0.87 + (t-0.7) * 0.43;        }                const blend = t * t * (3 - 2*t);                const x = p.sx * (1-blend) + tx * blend;        const y = p.sy * (1-blend) + ty * blend;        const z = p.sz * (1-blend) + tz * blend;                pos[i3] += (x - pos[i3]) * 0.05;        pos[i3+1] += (y - pos[i3+1]) * 0.05;        pos[i3+2] += (z - pos[i3+2]) * 0.05;      }            mesh.geometry.attributes.position.needsUpdate = true;            const camAngle = time * 0.02;      camera.position.x = Math.sin(camAngle) * 5;      camera.position.z = 35 + Math.cos(camAngle) * 5;      camera.lookAt(0, 0, 0);            renderer.render(scene, camera);    }        animate();    return () => {      cancelAnimationFrame(animationId);      window.removeEventListener('resize', handleResize);      if (mountRef.current && renderer.domElement) {        mountRef.current.removeChild(renderer.domElement);      }      geometry.dispose();      material.dispose();      renderer.dispose();    };  }, []);  return <div ref={mountRef} style={{     position: 'fixed',     top: 0,     left: 0,     width: '100vw',     height: '100vh',    zIndex: 0   }} />;}